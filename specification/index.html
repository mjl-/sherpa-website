<!doctype html>
<html>
	<head>
		<meta charset="utf-8" />
		<title>Specification - Sherpa</title>
		<link rel="stylesheet" href="../style.css" />
	</head>
	<body>
<div class="crumbs">
	<a href="../../">mjl</a> &gt;
	<a href="../">sherpa</a> &gt;
	<a class="last" href="./">specification</a>
</div>

<div class="tocbar">
	<a href="../">Sherpa</a> |
	<a class="active" href="../specification/">Specification</a> |
	<a href="../sherpajs/">Sherpajs</a> |
	<a href="../implementations/">Implementations</a> |
	<a href="../why/">Why</a> |
	<a href="../faq/">FAQ</a> |
	<a href="../about/">About</a>
</div>

<h1 id="specification">Specification</h1>

<p>
<strong>
WARNING: This specification is work in progress and will probably change.
</strong>
</p>

<p>
A Sherpa API is provided at a certain URL, for example <code>https://sherpa.irias.nl/exampleapi/</code>.  The API describes itself by a JSON file at <a href="https://sherpa.irias.nl/exampleapi/sherpa.json">https://sherpa.irias.nl/exampleapi/sherpa.json</a> Try opening it. It provides a document like the following.
</p>

<code><pre>
{
    "id": "exampleapi",
    "title": "Example API",
    "version": "0.0.1",
    "sherpaVersion": 0,
    "baseurl": "https://sherpa.irias.nl/exampleapi/",
    "functions": [
        "requestCount",
        "_docs"
    ]
}
</pre></code>

<p>
A Sherpa API must provide the endpoints described below.
</p>

<p>
The HTTP responses must include a CORS-header allowing access. This means they must also support the OPTIONS HTTP method.
</p>

<p>
All data in Sherpa is UTF-8. This includes JSON request and response bodies, and JavaScript. Sherpa does not look at "Content-Type" headers for character set information.
</p>

<h2>GET <code>&lt;URL&gt;/sherpa.json</code></h2>

<p>
A GET on the API URL must return a JSON document (as shown above). All fields are required.
</p>

<table>
	<thead>
		<tr>
			<th>Field</th>
			<th>Type</th>
			<th>Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>id</td>
			<td>string</td>
			<td>Short ID for this API. The JavaScript library stores the API object in a global variable with this name.</td>
		</tr>
		<tr>
			<td>title</td>
			<td>string</td>
			<td>Full human-readable name of this API.</td>
		</tr>
		<tr>
			<td>version</td>
			<td>string</td>
			<td>Descriptive version string. Could be in the form of major.minor.patch. But a single API endpoint should not really have different "major" versions at different times. Incompatible API versions are best deployed at a new endpoint.</td>
		</tr>
		<tr>
			<td>sherpaVersion</td>
			<td>int</td>
			<td>Version of the Sherpa specification. The current version while work in progress is 0. In the future, backwards compatible changes (e.g. adding fields to the JSON object describing the API) may be made without increasing the version number. For incompatible changes, the version number will be increased. If a client library loads a Sherpa API with a new version number, it must generate an error.</td>
		</tr>
		<tr>
			<td>baseurl</td>
			<td>string</td>
			<td>URL for this API.</td>
		</tr>
		<tr>
			<td>functions</td>
			<td>array of string</td>
			<td>List of methods exported by the API. Parameter types and return types are not part of the API. Requiring specification of such types would make the API significantly more complex and much harder to keep programming language-independent.</td>
		</tr>
	</tbody>
</table>

<h2>GET <code>&lt;URL&gt;/sherpa.js</code></h2>

<p>
This JavaScript file makes it trivial for people to start using your API.
</p>
<p>
The JavaScript file must set a global variable with the name of the "id" field in the API-describing JSON document. This variable must be an object providing all functions exported by the API. Calling such a function from JavaScript must return a "thenable" (an object with the <code>"function then(resolved, rejected) {...}"</code>). <code>Resolved</code> will be called with the result of a successful API call. <code>Rejected</code> will be called with an error object if the call failed.  Error objects are described later in this document.
</p>

<h2>POST <code>&lt;URL&gt;/<i>functionName</i></code></h2>

<p>
A POST is used to call a function.  The body must be a JSON document with a <code>params</code> field, an array with parameters. An example:
</p>

<code><pre>{
	"params": [
		"something",
		"else"
	]
}</pre></code>

<p>
The response is again a JSON document with fields <code>result</code> and <code>error</code>. A response must have at least one of those fields. Both can be present, but then one of these fields must be <code>null</code>.
</p>

<p>
On success, the <code>result</code> field contains the success response. The value can be any valid JSON type, e.g. boolean, an array, an object, etc. The value of field "result" is passed as argument to the resolved function in the JavaScript library.  An example:
</p>

<code><pre>{
    "result": ["some", "result"]
}</pre></code>

<p>
On error, the <code>error</code> field contains an error object. An error object in turn contains two fields: <code>message</code> and <code>code</code>. Field <code>message</code> is required. It should be a human-readable error message.  Field <code>code</code> is optional, can be null, but should be a string indicating the type of error. Programmers can write error-handling code that looks at the type of error. API's should document the error codes they can emit, and their semantics. An example error response:
</p>

<code><pre>{
    "error": {
        "message": "no permission to modify table X"
        "code": "permissionDenied"
    }
}</pre></code>

<h3>Notes on POST</h3>
<p>
The reason the function name is part of the URL and not part of the JSON body is purely convenience for web developers. With this scheme, it is easy to see which functions are being called in browser developer consoles showing HTTP requests. In an early draft of Sherpa, the function name was part of the JSON body in the request.
</p>

<p>
Error messages should start with a lower case letter and not end with a dot. This lets you easily combine (prepend/append) strings that create a full error message for display to the user.
</p>

<p>
HTTP status codes are not used to indicate success or failure. The POST should always return a status 200 "OK", even in case of an error. The exeption is if the function name does not exist. In that case, the HTTP status should be 404 "File not Found". The rationale is that if an API disappears, or a programmer used an incorrect API URL, function calls would return status 404 as well, so Sherpa libraries should expect and gracefully handle 404's anyway.
</p>

<h2 id="error-codes"><a href="#error-codes">Error codes</a></h2>
<p>
Sherpa also defines several commonly used error codes:
</p>
<dl>
	<dt>httpError</dt>
	<dd>An HTTP-level error occurred.</dd>

	<dt>sherpaBadFunction</dt>
	<dd>Method does not exist in this API. This might be returned by the server, of generated by the client library code.</dd>

	<dt>sherpaBadRequest</dt>
	<dd>Bad request body. Invalid JSON, or missing "params"-field.</dd>

	<dt>sherpaBadParams</dt>
	<dd>Method was not called with the correct number/type of parameters.</dd>

	<dt>sherpaHttpError</dt>
	<dd>The HTTP response status code indicated failure (everything except 200 and 404).</dd>

	<dt>sherpaBadResponse</dt>
	<dd>The HTTP response status code indicated success, but the response could not be parsed (e.g. malformed JSON in the body).</dd>

	<dt>sherpaClientError</dt>
	<dd>A client-side library error has occurred.</dd>

	<dt>sherpaNoAPI</dt>
	<dd>No API seems to be available at this URL (it returned a 404).</dd>
</dl>


<h2>GET <code>&lt;URL&gt;/</code></h2>
<p>
A GET on the Sherpa API base URL can optionally provide useful information about the API. A typical, though optional response is to redirect to a sherpaweb instance serving documentation for the API.
</p>

<h1 id="documentation">Documentation</h1>
<p>
A Sherpa API provides documentation through the function <code>_docs</code>. It is a function like any other, returning a JSON document as the result. Sherpaweb renders this document. The documentation must adhere to a simple format.  The object is a toplevel "documentation"-object, that looks like this:
</p>

<code><pre>{
    "title": "Title for this section of the documentation",
    "text": "Body of the documentation for this section, as markdown.",
    "functions": [
        {
            "name": "requestCount",
            "text": "Documentation for this function, as markdown.",
        },
        ...
    ],
    "sections": [
       ... a nested "documentation"-object,
       ...
    ]
}</pre></code>

<p>
Documentation can be hierarchically arranged. With a top-level documentation object introducing the API. And further topics divided in sections, each with their applicable functions.
</p>

<p>
Because the main text is markdown, you can easily create structure, or even include HTML for richer documentation.
</p>

<p>
The <code>text</code>-field in a "function"-object should start with a line containing the function signature, showcasing its parameters and their types, and the return type.
</p>


<h1>todo</h1>
<p>
Some things that could happen in the future:
</p>
<ul>
<li>Document that functions starting with a _ are special and should not normally be created. The JS lib uses _call to let you call a arbitrary functions by name. In the future, we will probably have _multicall.</li>
<li>Multicall support, JSONP support.</li>
<li>Describe the JS library in more detail.</li>
</ul>

<h1>Future development</h1>
<p>
Things not planned yet, but that may happen in the future.
</p>
<ul>
<li>Provide more structure for documentation. Such as explicit structure for function signatures, possible error codes.</li>
</ul>
	</body>
</html>
